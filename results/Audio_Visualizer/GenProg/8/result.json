{
  "repair_begin": "2020-08-10 21:53:10.715793",
  "repair_end": "2020-08-10 21:54:42.067317",
  "patches": [
    {
      "edits": [],
      "patch": "0a1,18\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\"\n> # 1 \"<built-in>\" 1\n> # 1 \"<built-in>\" 3\n> # 336 \"<built-in>\" 3\n> # 1 \"<command line>\" 1\n> # 1 \"<built-in>\" 2\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\" 2\n> # 26 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\"\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/cgc_uwfc.h\" 1\n> \n> \n> \n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stdlib.h\" 1\n> \n> \n> \n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/include/libcgc.h\" 1\n> # 19 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/include/libcgc.h\"\n3,7c21,29\n< typedef long _fd_mask;\n< struct __anonstruct_cgc_fd_set_1 {\n<    _fd_mask _fd_bits[1024UL / (8UL * sizeof(_fd_mask ))] ;\n< };\n< typedef struct __anonstruct_cgc_fd_set_1 cgc_fd_set;\n---\n> # 51 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/include/libcgc.h\"\n> typedef long int _fd_mask;\n> \n> \n> \n> typedef struct {\n>     _fd_mask _fd_bits[1024 / (8 * sizeof(_fd_mask))];\n> } cgc_fd_set;\n> # 75 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/include/libcgc.h\"\n9,10c31,32\n<    int tv_sec ;\n<    int tv_usec ;\n---\n>     int tv_sec;\n>     int tv_usec;\n12,15c34,87\n< struct __anonstruct_jmp_buf_2 {\n<    long _b[8] ;\n< };\n< typedef struct __anonstruct_jmp_buf_2 jmp_buf[1];\n---\n> # 122 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/include/libcgc.h\"\n> void cgc__terminate(unsigned int status) __attribute__((__noreturn__));\n> int cgc_transmit(int fd, const void *buf, cgc_size_t count, cgc_size_t *tx_bytes);\n> int cgc_receive(int fd, void *buf, cgc_size_t count, cgc_size_t *rx_bytes);\n> int cgc_fdwait(int nfds, cgc_fd_set *readfds, cgc_fd_set *writefds,\n>                const struct cgc_timeval *timeout, int *readyfds);\n> int cgc_allocate(cgc_size_t length, int is_X, void **addr);\n> int cgc_deallocate(void *addr, cgc_size_t length);\n> int cgc_random(void *buf, cgc_size_t count, cgc_size_t *rnd_bytes);\n> \n> \n> \n> typedef struct { long _b[8]; } jmp_buf[1];\n> extern int cgc_setjmp(jmp_buf) __attribute__((__returns_twice__));\n> extern void cgc_longjmp(jmp_buf, int) __attribute__((__noreturn__));\n> \n> extern float cgc_sinf(float); extern double cgc_sin(double); extern long double cgc_sinl(long double);\n> extern float cgc_cosf(float); extern double cgc_cos(double); extern long double cgc_cosl(long double);\n> extern float cgc_tanf(float); extern double cgc_tan(double); extern long double cgc_tanl(long double);\n> extern float cgc_logf(float); extern double cgc_log(double); extern long double cgc_logl(long double);\n> extern float cgc_rintf(float); extern double cgc_rint(double); extern long double cgc_rintl(long double);\n> extern float cgc_sqrtf(float); extern double cgc_sqrt(double); extern long double cgc_sqrtl(long double);\n> extern float cgc_fabsf(float); extern double cgc_fabs(double); extern long double cgc_fabsl(long double);\n> extern float cgc_log2f(float); extern double cgc_log2(double); extern long double cgc_log2l(long double);\n> extern float cgc_exp2f(float); extern double cgc_exp2(double); extern long double cgc_exp2l(long double);\n> extern float cgc_expf(float); extern double cgc_exp(double); extern long double cgc_expl(long double);\n> extern float cgc_log10f(float); extern double cgc_log10(double); extern long double cgc_log10l(long double);\n> \n> extern float cgc_powf(float, float);\n> extern double cgc_pow(double, double);\n> extern long double cgc_powl(long double, long double);\n> extern float cgc_atan2f(float, float);\n> extern double cgc_atan2(double, double);\n> extern long double cgc_atan2l(long double, long double);\n> extern float cgc_remainderf(float, float);\n> extern double cgc_remainder(double, double);\n> extern long double cgc_remainderl(long double, long double);\n> extern float cgc_scalbnf(float, int);\n> extern double cgc_scalbn(double, int);\n> extern long double cgc_scalbnl(long double, int);\n> extern float cgc_scalblnf(float, long int);\n> extern double cgc_scalbln(double, long int);\n> extern long double cgc_scalblnl(long double, long int);\n> extern float cgc_significandf(float);\n> extern double cgc_significand(double);\n> extern long double cgc_significandl(long double);\n> # 5 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stdlib.h\" 2\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stdarg.h\" 1\n> \n> \n> \n> \n> \n> \n16a89,92\n> \n> \n> \n> \n18,228c94,95\n< typedef long ptrdiff_t;\n< struct __anonstruct_uwfc_t_3 {\n<    unsigned char chunk_id[4] ;\n<    unsigned int chunk_size ;\n<    unsigned char format[4] ;\n<    unsigned char sub_chunk1_id[4] ;\n<    unsigned int sub_chunk1_size ;\n<    unsigned short audio_format ;\n<    unsigned short num_channels ;\n<    unsigned int sample_rate ;\n<    unsigned int byte_rate ;\n<    unsigned short block_align ;\n<    unsigned short bits_per_sample ;\n<    unsigned char sub_chunk2_id[4] ;\n<    unsigned int sub_chunk2_size ;\n<    char *data ;\n< };\n< typedef struct __anonstruct_uwfc_t_3 uwfc_t;\n< struct __anonstruct_complex_t_4 {\n<    double real ;\n<    double imag ;\n< };\n< typedef struct __anonstruct_complex_t_4 complex_t;\n< struct __anonstruct_eq_bucket_t_5 {\n<    double total_power ;\n<    double max_power ;\n<    int freq_count ;\n< };\n< typedef struct __anonstruct_eq_bucket_t_5 eq_bucket_t;\n< extern  __attribute__((__noreturn__)) void cgc__terminate(unsigned int status ) ;\n< extern int cgc_transmit(int fd , void const   *buf , cgc_size_t count ,\n<                         cgc_size_t *tx_bytes ) ;\n< extern int cgc_receive(int fd , void *buf , cgc_size_t count ,\n<                        cgc_size_t *rx_bytes ) ;\n< extern int cgc_fdwait(int nfds , cgc_fd_set *readfds , cgc_fd_set *writefds ,\n<                       struct cgc_timeval  const  *timeout , int *readyfds ) ;\n< extern int cgc_allocate(cgc_size_t length , int is_X , void **addr ) ;\n< extern int cgc_deallocate(void *addr , cgc_size_t length ) ;\n< extern int cgc_random(void *buf , cgc_size_t count , cgc_size_t *rnd_bytes ) ;\n< extern int cgc_setjmp(struct __anonstruct_jmp_buf_2 * )  __attribute__((__returns_twice__)) ;\n< extern  __attribute__((__noreturn__)) void cgc_longjmp(struct __anonstruct_jmp_buf_2 * ,\n<                                                        int  ) ;\n< extern float cgc_sinf(float  ) ;\n< extern double cgc_sin(double  ) ;\n< extern long double cgc_sinl(long double  ) ;\n< extern float cgc_cosf(float  ) ;\n< extern double cgc_cos(double  ) ;\n< extern long double cgc_cosl(long double  ) ;\n< extern float cgc_tanf(float  ) ;\n< extern double cgc_tan(double  ) ;\n< extern long double cgc_tanl(long double  ) ;\n< extern float cgc_logf(float  ) ;\n< extern double cgc_log(double  ) ;\n< extern long double cgc_logl(long double  ) ;\n< extern float cgc_rintf(float  ) ;\n< extern double cgc_rint(double  ) ;\n< extern long double cgc_rintl(long double  ) ;\n< extern float cgc_sqrtf(float  ) ;\n< extern double cgc_sqrt(double  ) ;\n< extern long double cgc_sqrtl(long double  ) ;\n< extern float cgc_fabsf(float  ) ;\n< extern double cgc_fabs(double  ) ;\n< extern long double cgc_fabsl(long double  ) ;\n< extern float cgc_log2f(float  ) ;\n< extern double cgc_log2(double  ) ;\n< extern long double cgc_log2l(long double  ) ;\n< extern float cgc_exp2f(float  ) ;\n< extern double cgc_exp2(double  ) ;\n< extern long double cgc_exp2l(long double  ) ;\n< extern float cgc_expf(float  ) ;\n< extern double cgc_exp(double  ) ;\n< extern long double cgc_expl(long double  ) ;\n< extern float cgc_log10f(float  ) ;\n< extern double cgc_log10(double  ) ;\n< extern long double cgc_log10l(long double  ) ;\n< extern float cgc_powf(float  , float  ) ;\n< extern double cgc_pow(double  , double  ) ;\n< extern long double cgc_powl(long double  , long double  ) ;\n< extern float cgc_atan2f(float  , float  ) ;\n< extern double cgc_atan2(double  , double  ) ;\n< extern long double cgc_atan2l(long double  , long double  ) ;\n< extern float cgc_remainderf(float  , float  ) ;\n< extern double cgc_remainder(double  , double  ) ;\n< extern long double cgc_remainderl(long double  , long double  ) ;\n< extern float cgc_scalbnf(float  , int  ) ;\n< extern double cgc_scalbn(double  , int  ) ;\n< extern long double cgc_scalbnl(long double  , int  ) ;\n< extern float cgc_scalblnf(float  , long  ) ;\n< extern double cgc_scalbln(double  , long  ) ;\n< extern long double cgc_scalblnl(long double  , long  ) ;\n< extern float cgc_significandf(float  ) ;\n< extern double cgc_significand(double  ) ;\n< extern long double cgc_significandl(long double  ) ;\n< extern int cgc_printf(char const   *fmt  , ...) ;\n< extern long cgc_strtol(char const   *str , char **endptr , int base ) ;\n< extern unsigned long strtoul(char const   *str , char **endptr , int base ) ;\n< extern void *cgc_malloc(cgc_size_t size ) ;\n< extern void *cgc_calloc(cgc_size_t nmemb , cgc_size_t size ) ;\n< extern void *cgc_realloc(void *ptr , cgc_size_t size ) ;\n< extern void cgc_free(void *ptr ) ;\n< extern cgc_size_t malloc_size(void *ptr ) ;\n< static void cgc_exit(int ret ) \n< { \n< \n< \n<   {\n<   cgc__terminate((unsigned int )ret);\n< }\n< }\n< int cgc_validate_header(uwfc_t *header ) ;\n< uwfc_t *cgc_init_track(void) ;\n< void cgc_clear_track(uwfc_t **uwfc_track ) ;\n< void cgc_wave_vis(uwfc_t *track ) ;\n< void cgc_eq_vis(uwfc_t *track , int vis_type , int filter_type ) ;\n< extern void low_pass_filter(uwfc_t *track ) ;\n< extern void high_pass_filter(uwfc_t *track ) ;\n< void cgc_set_vis_multiplier(char c ) ;\n< int cgc_get_vis_multiplier(void) ;\n< extern complex_t *cgc_dft(double *real_coeff , unsigned int samples , int *len ) ;\n< extern double *cgc_idft(complex_t *coeff , unsigned int samples , int *len ) ;\n< extern void *cgc_memcpy(void *dest , void const   *src , cgc_size_t n ) ;\n< extern void *cgc_memmove(void *dest , void const   *src , cgc_size_t n ) ;\n< extern void *cgc_memset(void *dest , int c , cgc_size_t n ) ;\n< extern int cgc_memcmp(void *s1 , void const   *s2 , cgc_size_t n ) ;\n< extern void *memchr(void const   *s , int c , cgc_size_t n ) ;\n< extern cgc_size_t cgc_strlen(char const   *s ) ;\n< extern char *cgc_strcpy(char *dest , char const   *src ) ;\n< extern char *cgc_strncpy(char *dest , char const   *src , cgc_size_t n ) ;\n< extern char *cgc_strchr(char const   *s , int c ) ;\n< extern char *cgc_strsep(char **stringp , char const   *delim ) ;\n< extern int strcmp(char const   *a , char const   *b ) ;\n< static unsigned long const   UWFC_HEADER_SIZE  =    (cgc_size_t const   )(sizeof(uwfc_t ) - sizeof(char *));\n< static int vis_multiplier  =    0;\n< void cgc_set_vis_multiplier(char c ) \n< { \n< \n< \n<   {\n<   if ((int )c <= 57) {\n<     if ((int )c >= 48) {\n<       vis_multiplier = (int )c - 48;\n<       cgc_printf(\"Multiplier set to %d\\n\", (int )c - 48);\n<     } else {\n<       cgc_printf(\"Bad multiplier arguments\\n\");\n<     }\n<   } else {\n<     cgc_printf(\"Bad multiplier arguments\\n\");\n<   }\n<   return;\n< }\n< }\n< int cgc_get_vis_multiplier(void) \n< { \n< \n< \n<   {\n<   return (vis_multiplier);\n< }\n< }\n< int cgc_validate_header(uwfc_t *header ) \n< { \n<   char *magic ;\n<   char *audio_fmt ;\n<   char *sub_chunk1_id ;\n<   char *sub_chunk2_id ;\n<   int tmp ;\n<   unsigned char *temp ;\n<   int tmp___0 ;\n<   int tmp___1 ;\n<   int tmp___2 ;\n< \n<   {\n<   magic = (char *)\"FFIR\";\n<   audio_fmt = (char *)\"UWFC\";\n<   sub_chunk1_id = (char *)\"cgc \";\n<   sub_chunk2_id = (char *)\"data\";\n<   tmp = cgc_memcmp((void *)(header->chunk_id), (void const   *)magic,\n<                    (cgc_size_t )4);\n<   if (tmp != 0) {\n<     return (- (1 << 1));\n<   } else {\n< \n<   }\n<   if (header->chunk_size != (4U + (8U + header->sub_chunk1_size)) + (8U + header->sub_chunk2_size)) {\n<     return (- (1 << 2));\n<   } else {\n< \n<   }\n<   temp = & header->format[0];\n<   tmp___0 = cgc_memcmp((void *)temp, (void const   *)audio_fmt, (cgc_size_t )4);\n<   if (tmp___0 != 0) {\n<     return (- (1 << 3));\n<   } else {\n< \n<   }\n<   tmp___1 = cgc_memcmp((void *)(header->sub_chunk1_id),\n<                        (void const   *)sub_chunk1_id, (cgc_size_t )4);\n<   if (tmp___1 != 0) {\n<     return (- (1 << 4));\n<   } else {\n< \n<   }\n<   if ((int )header->audio_format != 1) {\n<     return (- (1 << 5));\n<   } else {\n< \n<   }\n<   if ((int )header->num_channels != 1) {\n<     if ((int )header->num_channels != 2) {\n<       return (- (1 << 6));\n<     } else {\n---\n> # 6 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stdlib.h\" 2\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stddef.h\" 1\n230,231d96\n<     }\n<   } else {\n233,240d97\n<   }\n<   if (header->sample_rate != 8000U) {\n<     if (header->sample_rate != 11025U) {\n<       if (header->sample_rate != 16000U) {\n<         if (header->sample_rate != 22050U) {\n<           if ((int )header->block_align != ((int )header->num_channels * (int )header->bits_per_sample) / 8) {\n<             return (- (1 << 8));\n<           } else {\n242,243d98\n<           }\n<         } else {\n245,246d99\n<         }\n<       } else {\n248,249c101,102\n<       }\n<     } else {\n---\n> typedef long int ptrdiff_t;\n> # 7 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_stdlib.h\" 2\n251,252c104\n<     }\n<   } else {\n---\n> extern int cgc_printf(const char *fmt, ...);\n254,265c106,107\n<   }\n<   if (header->byte_rate != ((header->sample_rate * (unsigned int )header->num_channels) * (unsigned int )header->bits_per_sample) / 8U) {\n<     return (- (1 << 8));\n<   } else {\n< \n<   }\n<   if (header->sample_rate != 32000U) {\n<     if (header->sample_rate != 44100U) {\n<       if (header->sample_rate != 48000U) {\n<         if (header->sample_rate != 4000U) {\n<           return (- (1 << 7));\n<         } else {\n---\n> long cgc_strtol(const char *str, char **endptr, int base);\n> unsigned long strtoul(const char *str, char **endptr, int base);\n267,268c109,113\n<         }\n<       } else {\n---\n> extern void *cgc_malloc(cgc_size_t size);\n> extern void *cgc_calloc(cgc_size_t nmemb, cgc_size_t size);\n> extern void *cgc_realloc(void *ptr, cgc_size_t size);\n> extern void cgc_free(void *ptr);\n> extern cgc_size_t malloc_size(void *ptr);\n270,271c115,119\n<       }\n<     } else {\n---\n> static void cgc_exit(int ret)\n> {\n>     cgc__terminate(ret);\n> }\n> # 5 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/cgc_uwfc.h\" 2\n273,274c121,132\n<     }\n<   } else {\n---\n> typedef struct {\n>     unsigned char chunk_id[4];\n>     unsigned int chunk_size;\n>     unsigned char format[4];\n>     unsigned char sub_chunk1_id[4];\n>     unsigned int sub_chunk1_size;\n>     unsigned short audio_format;\n>     unsigned short num_channels;\n>     unsigned int sample_rate;\n>     unsigned int byte_rate;\n>     unsigned short block_align;\n>     unsigned short bits_per_sample;\n276,280c134,137\n<   }\n<   if ((int )header->bits_per_sample != 8) {\n<     if ((int )header->bits_per_sample != 16) {\n<       return (- (1 << 10));\n<     } else {\n---\n>     unsigned char sub_chunk2_id[4];\n>     unsigned int sub_chunk2_size;\n>     char* data;\n> } uwfc_t;\n282,283c139,141\n<     }\n<   } else {\n---\n> int cgc_validate_header(uwfc_t *header);\n> uwfc_t *cgc_init_track();\n> void cgc_clear_track(uwfc_t **uwfc_track);\n285,346c143,150\n<   }\n<   tmp___2 = cgc_memcmp((void *)(header->sub_chunk2_id),\n<                        (void const   *)sub_chunk2_id, (cgc_size_t )4);\n<   if (tmp___2 != 0) {\n<     return (- (1 << 11));\n<   } else {\n< \n<   }\n<   return ((int )(header->chunk_size + 8U));\n< }\n< }\n< uwfc_t *cgc_init_track(void) \n< { \n<   uwfc_t *track ;\n<   int track_size ;\n<   cgc_size_t rx ;\n<   cgc_size_t rx_count ;\n<   void *tmp ;\n<   int tmp___0 ;\n<   int tmp___1 ;\n<   void *tmp___2 ;\n<   int tmp___3 ;\n< \n<   {\n<   track_size = 0;\n<   rx = (cgc_size_t )0;\n<   rx_count = (cgc_size_t )0;\n<   tmp = cgc_malloc(sizeof(uwfc_t ));\n<   track = (uwfc_t *)tmp;\n<   if ((unsigned long )track == (unsigned long )((uwfc_t *)0)) {\n<     return ((uwfc_t *)0);\n<   } else {\n< \n<   }\n<   tmp___0 = cgc_receive(0, (void *)track, (cgc_size_t )UWFC_HEADER_SIZE, & rx);\n<   if (tmp___0 != 0) {\n<     cgc_free((void *)track);\n<     return ((uwfc_t *)0);\n<   } else\n<   if (rx != (cgc_size_t )UWFC_HEADER_SIZE) {\n<     cgc_free((void *)track);\n<     return ((uwfc_t *)0);\n<   } else {\n< \n<   }\n<   tmp___1 = cgc_validate_header(track);\n<   track_size = (int )((unsigned long const   )tmp___1 - UWFC_HEADER_SIZE);\n<   if (track_size < 0) {\n<     cgc_free((void *)track);\n<     return ((uwfc_t *)0);\n<   } else {\n< \n<   }\n<   if (track_size == 0) {\n<     track->data = (char *)0;\n<   } else {\n<     tmp___2 = cgc_malloc((cgc_size_t )track_size);\n<     track->data = (char *)tmp___2;\n<     if ((unsigned long )track->data == (unsigned long )((char *)0)) {\n<       cgc_free((void *)track);\n<       return ((uwfc_t *)0);\n<     } else {\n---\n> void cgc_wave_vis(uwfc_t *track);\n> void cgc_eq_vis(uwfc_t *track, int vis_type, int filter_type);\n> void low_pass_filter(uwfc_t *track);\n> void high_pass_filter(uwfc_t *track);\n> void cgc_set_vis_multiplier(char c);\n> int cgc_get_vis_multiplier();\n> # 27 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\" 2\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/cgc_dft.h\" 1\n348,358c152,189\n<     }\n<   }\n<   while (1) {\n<     tmp___3 = cgc_receive(0, (void *)(track->data + rx_count),\n<                           (cgc_size_t )track->sub_chunk2_size - rx_count, & rx);\n<     if (tmp___3 == 0) {\n<       if (rx_count + rx != (cgc_size_t )track->sub_chunk2_size) {\n< \n<       } else {\n<         break;\n<       }\n---\n> \n> \n> typedef struct {\n>     double real;\n>     double imag;\n> } complex_t;\n> \n> \n> complex_t *cgc_dft(double *real_coeff, unsigned int samples, int *len);\n> double *cgc_idft(complex_t *coeff, unsigned int samples, int *len);\n> # 28 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\" 2\n> # 1 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/lib/cgc_string.h\" 1\n> \n> \n> \n> \n> \n> extern void *cgc_memcpy(void *dest, const void *src, cgc_size_t n);\n> extern void *cgc_memmove(void *dest, const void *src, cgc_size_t n);\n> extern void *cgc_memset(void *dest, int c, cgc_size_t n);\n> extern int cgc_memcmp(void *s1, const void *s2, cgc_size_t n);\n> extern void *memchr(const void *s, int c, cgc_size_t n);\n> \n> extern cgc_size_t cgc_strlen(const char *s);\n> extern char *cgc_strcpy(char *dest, const char *src);\n> extern char *cgc_strncpy(char *dest, const char *src, cgc_size_t n);\n> extern char *cgc_strchr(const char *s, int c);\n> extern char *cgc_strsep(char **stringp, const char *delim);\n> extern int strcmp(const char* a, const char *b);\n> # 29 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\" 2\n> # 55 \"/home/epicosy/thesis/implementation/repair/SecureThemAll2/benchmark/cb-multios/challenges/Audio_Visualizer/src/uwfc.c\"\n> static const cgc_size_t UWFC_HEADER_SIZE = sizeof(uwfc_t) - sizeof(char *);\n> static int vis_multiplier = 0;\n> \n> void cgc_set_vis_multiplier(char c) {\n>     if (c <= '9' && c >= '0') {\n>         vis_multiplier = c - '0';\n>         cgc_printf(\"Multiplier set to %d\\n\", c - '0');\n360c191\n<       break;\n---\n>         cgc_printf(\"Bad multiplier arguments\\n\");\n362,366c193,244\n<     if (rx == 0UL) {\n<       cgc_free((void *)track->data);\n<       cgc_free((void *)track);\n<       return ((uwfc_t *)0);\n<     } else {\n---\n> }\n> \n> int cgc_get_vis_multiplier() {\n>     return vis_multiplier;\n> }\n> \n> int cgc_validate_header(uwfc_t *header) {\n>     char *magic = \"FFIR\";\n>     char *audio_fmt = \"UWFC\";\n>     char *sub_chunk1_id = \"cgc \";\n>     char *sub_chunk2_id = \"data\";\n> \n> \n>     if (cgc_memcmp(header->chunk_id, magic, 4) != 0)\n>         return -(1 << 1);\n> \n>     if (header->chunk_size != (4 + (8 + header->sub_chunk1_size) + (8 + header->sub_chunk2_size)))\n>         return -(1 << 2);\n> \n> \n>     unsigned char *temp = &header->format[0];\n>     if (cgc_memcmp(temp, audio_fmt, 4) != 0)\n>         return -(1 << 3);\n> \n> \n>     if (cgc_memcmp(header->sub_chunk1_id, sub_chunk1_id, 4) != 0)\n>         return -(1 << 4);\n> \n> \n>     if (header->audio_format != 1)\n>         return -(1 << 5);\n> \n> \n>     if (header->num_channels != 1 && header->num_channels != 2)\n>         return -(1 << 6);\n> \n>     if (header->sample_rate != 8000 && header->sample_rate != 11025 &&\n>         header->sample_rate != 16000 && header->sample_rate != 22050 &&\n>         header->sample_rate != 32000 && header->sample_rate != 44100 &&\n>         header->sample_rate != 48000 && header->sample_rate != 4000)\n>         return -(1 << 7);\n> \n>     if (header->byte_rate !=\n>         (header->sample_rate * header->num_channels * header->bits_per_sample/8))\n>         return -(1 << 8);\n> \n>     if (header->block_align != (header->num_channels * header->bits_per_sample/8))\n>         return -(1 << 8);\n> \n> \n>     if (header->bits_per_sample != 8 && header->bits_per_sample != 16)\n>         return -(1 << 10);\n368,497d245\n<     }\n<     rx_count += rx;\n<   }\n<   return (track);\n< }\n< }\n< void cgc_clear_track(uwfc_t **uwfc_track ) \n< { \n<   uwfc_t *track ;\n< \n<   {\n<   track = *uwfc_track;\n<   if ((unsigned long )track == (unsigned long )((uwfc_t *)0)) {\n<     return;\n<   } else {\n< \n<   }\n<   if ((unsigned long )track->data != (unsigned long )((char *)0)) {\n<     cgc_free((void *)track->data);\n<   } else {\n< \n<   }\n<   if ((unsigned long )track != (unsigned long )((uwfc_t *)0)) {\n<     cgc_free((void *)track);\n<   } else {\n< \n<   }\n<   *uwfc_track = (uwfc_t *)0;\n<   return;\n< }\n< }\n< static void cgc_slow_vis(void) \n< { \n<   int i ;\n<   double tmp ;\n<   double tmp___0 ;\n< \n<   {\n<   i = 0;\n<   i = 0;\n<   while (i < 200000 * vis_multiplier) {\n<     tmp = cgc_sin((double )i);\n<     tmp___0 = cgc_cos((double )i);\n<     i ++;\n<   }\n<   return;\n< }\n< }\n< static void cgc_plot_mono_wave(uwfc_t *track , unsigned char *data ) \n< { \n<   double normalized ;\n<   int w ;\n<   int y ;\n<   int x ;\n<   char *line ;\n<   unsigned long __lengthofline ;\n<   void *tmp ;\n< \n<   {\n<   normalized = (double )0;\n<   if ((int )track->bits_per_sample == 8) {\n<     normalized = (double )((int )*data - 127) / (double )127;\n<   } else {\n<     normalized = (double )*((short *)data) / (double )32767;\n<   }\n<   w = 42;\n<   y = (w - 1) / 2;\n<   x = (int )((normalized * (double )y + (double )y) + .5);\n<   __lengthofline = (unsigned long )w;\n<   tmp = __builtin_alloca(sizeof(*line) * __lengthofline);\n<   line = (char *)tmp;\n<   cgc_memset((void *)line, ' ', (cgc_size_t )w);\n<   *(line + (w - 1)) = (char )'\\000';\n<   *(line + x) = (char )'*';\n<   cgc_printf(\"%s\\n\", line);\n<   return;\n< }\n< }\n< static void cgc_plot_stereo_wave(uwfc_t *track , unsigned char *data ) \n< { \n<   double normalized_l ;\n<   double normalized_r ;\n<   int w ;\n<   int chan_w ;\n<   int y ;\n<   int x_l ;\n<   int x_r ;\n<   char *line ;\n<   unsigned long __lengthofline ;\n<   void *tmp ;\n< \n<   {\n<   normalized_l = (double )0;\n<   normalized_r = (double )0;\n<   if ((int )track->bits_per_sample == 8) {\n<     normalized_l = (double )((int )*data - 127) / (double )127;\n<     normalized_r = (double )((int )*(data + 1) - 127) / (double )127;\n<   } else {\n<     normalized_l = (double )*((short *)data) / (double )32767;\n<     normalized_r = (double )*((short *)(data + 2)) / (double )32767;\n<   }\n<   w = 83;\n<   chan_w = w / 2;\n<   y = (chan_w - 2) / 2;\n<   x_l = (int )((normalized_l * (double )y + (double )y) + .5);\n<   x_r = (int )(((normalized_r * (double )y + (double )y) + (double )chan_w) + 1.5);\n<   __lengthofline = (unsigned long )w;\n<   tmp = __builtin_alloca(sizeof(*line) * __lengthofline);\n<   line = (char *)tmp;\n<   cgc_memset((void *)line, ' ', (cgc_size_t )w);\n<   *(line + (w - 1)) = (char )'\\000';\n<   *(line + chan_w) = (char )'|';\n<   *(line + x_l) = (char )'*';\n<   *(line + x_r) = (char )'*';\n<   cgc_printf(\"%s\\n\", line);\n<   return;\n< }\n< }\n< void cgc_wave_vis(uwfc_t *track ) \n< { \n<   unsigned char *data ;\n<   cgc_size_t i ;\n< \n<   {\n<   data = (unsigned char *)track->data;\n<   i = (cgc_size_t )0;\n<   while (i < (cgc_size_t )(track->sub_chunk2_size / (unsigned int )track->block_align)) {\n<     if (i % (unsigned long )track->sample_rate == 0UL) {\n<       cgc_slow_vis();\n<     } else {\n498a247,268\n>     if (cgc_memcmp(header->sub_chunk2_id, sub_chunk2_id, 4) != 0)\n>         return -(1 << 11);\n> \n> \n>     return header->chunk_size + 8;\n> \n> \n> \n> }\n> \n> uwfc_t *cgc_init_track() {\n>     uwfc_t *track;\n>     int track_size = 0;\n>     cgc_size_t rx = 0, rx_count = 0;\n> \n>     track = cgc_malloc(sizeof(uwfc_t));\n>     if (track == (0))\n>         return (0);\n> \n>     if (cgc_receive(0, track, UWFC_HEADER_SIZE, &rx) != 0 || rx != UWFC_HEADER_SIZE) {\n>         cgc_free(track);\n>         return (0);\n500,505d269\n<     if ((int )track->num_channels == 2) {\n<       cgc_plot_stereo_wave(track, data);\n<     } else\n<     if ((int )track->num_channels == 1) {\n<       cgc_plot_mono_wave(track, data);\n<     } else {\n506a271,280\n> \n>     track_size = cgc_validate_header(track) - UWFC_HEADER_SIZE;\n> \n> \n> \n> \n> \n>     if (track_size < 0) {\n>         cgc_free(track);\n>         return (0);\n508,581d281\n<     i ++;\n<     data += (int )track->block_align;\n<   }\n<   cgc_printf(\"++++END VISUALIZATION++++\\n\\n\");\n<   return;\n< }\n< }\n< static void cgc_add_to_bucket(eq_bucket_t *buckets , complex_t *f , int f_i ,\n<                               int f_max ) \n< { \n<   int b_i ;\n<   double tmp ;\n<   double power ;\n<   eq_bucket_t *bucket ;\n<   double tmp___0 ;\n<   double tmp___1 ;\n< \n<   {\n<   tmp = cgc_sqrt((double )f_i / (double )f_max);\n<   b_i = (int )(tmp * (double )12);\n<   bucket = buckets + b_i;\n<   tmp___0 = cgc_pow(f->real, (double )2);\n<   tmp___1 = cgc_pow(f->imag, (double )2);\n<   power = tmp___0 + tmp___1;\n<   if (power > (double )4) {\n<     bucket->total_power += power;\n<   } else {\n< \n<   }\n<   if (bucket->max_power < power) {\n<     bucket->max_power = power;\n<   } else {\n< \n<   }\n<   (bucket->freq_count) ++;\n<   return;\n< }\n< }\n< static void cgc_vis_buckets(eq_bucket_t *buckets , int vis_type ) \n< { \n<   int i ;\n<   int max_height ;\n<   char *line ;\n<   unsigned long __lengthofline ;\n<   void *tmp ;\n<   int h ;\n<   double tmp___0 ;\n<   double total_power ;\n<   int bar_width ;\n<   int bar_len ;\n<   double tmp___1 ;\n< \n<   {\n<   max_height = 90;\n<   __lengthofline = (unsigned long )(max_height + 1);\n<   tmp = __builtin_alloca(sizeof(*line) * __lengthofline);\n<   line = (char *)tmp;\n<   cgc_slow_vis();\n<   if (vis_type == 1) {\n<     h = max_height;\n<     while (h >= 0) {\n<       cgc_printf(\"   \");\n<       i = 0;\n<       while (i < 12) {\n<         if (h == 0) {\n<           cgc_printf(\"|-----|\");\n<         } else {\n<           tmp___0 = cgc_log((buckets + i)->max_power);\n<           if (h <= (int )tmp___0) {\n<             cgc_printf(\"|=====|\");\n<           } else\n<           if (h <= 30) {\n<             cgc_printf(\"|     |\");\n<           } else {\n583c283,289\n<           }\n---\n>     if (track_size == 0) {\n>         track->data = (0);\n>     } else {\n>         track->data = cgc_malloc(track_size);\n>         if (track->data == (0)) {\n>             cgc_free(track);\n>             return (0);\n585,588d290\n<         i ++;\n<       }\n<       cgc_printf(\"\\n\");\n<       h --;\n590,608c292,301\n<   } else\n<   if (vis_type == 2) {\n<     total_power = (double )0;\n<     bar_width = 2;\n<     bar_len = 0;\n<     i = 0;\n<     while (i < 12) {\n<       total_power += (buckets + i)->total_power;\n<       i ++;\n<     }\n<     tmp___1 = cgc_log(total_power + (double )1);\n<     bar_len = (int )(tmp___1 * (double )3);\n<     cgc_memset((void *)line, 0, (cgc_size_t )(max_height + 1));\n<     cgc_memset((void *)line, '=', (cgc_size_t )bar_len);\n<     *(line + bar_len) = (char )']';\n<     i = 0;\n<     while (i < bar_width) {\n<       cgc_printf(\"%s\\n\", line);\n<       i ++;\n---\n> \n>     while (cgc_receive(0, &track->data[rx_count], (track->sub_chunk2_size - rx_count), &rx) == 0 &&\n>             (rx_count + rx) != track->sub_chunk2_size) {\n>         if(rx == 0) {\n>             cgc_free(track->data);\n>             cgc_free(track);\n>             return (0);\n>         }\n> \n>         rx_count += rx;\n610d302\n<   } else {\n612,613c304,317\n<   }\n<   return;\n---\n>     return track;\n> }\n> \n> void cgc_clear_track(uwfc_t **uwfc_track) {\n>     uwfc_t *track = *uwfc_track;\n>     if (track == (0))\n>         return;\n> \n>     if (track->data != (0))\n>         cgc_free(track->data);\n> \n>     if(track != (0))\n>         cgc_free(track);\n>     *uwfc_track = (0);\n614a319,323\n> \n> static void cgc_slow_vis() {\n>     int i = 0;\n>     for(i = 0; i < 200000 * vis_multiplier; i++)\n>         cgc_sin(i) / (cgc_cos(i) + 1);\n616,649d324\n< void cgc_eq_vis(uwfc_t *track , int vis_type , int filter_type ) \n< { \n<   int i ;\n<   int j ;\n<   int len ;\n<   unsigned char *data ;\n<   double *dft_inputs_l ;\n<   double *dft_inputs_r ;\n<   complex_t *dft_output_l ;\n<   complex_t *dft_output_r ;\n<   double normalized_l ;\n<   double normalized_r ;\n<   eq_bucket_t freq_bars[12] ;\n<   void *tmp ;\n<   void *tmp___0 ;\n<   int k ;\n< \n<   {\n<   data = (unsigned char *)track->data;\n<   dft_output_l = (complex_t *)0;\n<   dft_output_r = (complex_t *)0;\n<   tmp = cgc_malloc((unsigned long )track->sample_rate * sizeof(double ));\n<   dft_inputs_l = (double *)tmp;\n<   if ((unsigned long )dft_inputs_l == (unsigned long )((double *)0)) {\n<     return;\n<   } else {\n< \n<   }\n<   if ((int )track->num_channels == 2) {\n<     tmp___0 = cgc_malloc((unsigned long )track->sample_rate * sizeof(double ));\n<     dft_inputs_r = (double *)tmp___0;\n<     if ((unsigned long )dft_inputs_r == (unsigned long )((double *)0)) {\n<       return;\n<     } else {\n650a326,356\n> \n> static void cgc_plot_mono_wave(uwfc_t *track, unsigned char *data) {\n>     double normalized = 0;\n> \n>     if (track->bits_per_sample == 8)\n>         normalized = (*data - 127) / (double)127;\n>     else\n>         normalized = (*((short *)data)) / (double)32767;\n> \n> \n>     const int w = 42;\n>     int y = (w - 1) / 2;\n>     int x = (normalized * y) + y + .5;\n>     char line[w];\n>     cgc_memset(line, ' ', w);\n>     line[w-1] = '\\0';\n>     line[x] = '*';\n>     cgc_printf(\"%s\\n\", line);\n> \n> }\n> \n> static void cgc_plot_stereo_wave(uwfc_t *track, unsigned char *data) {\n>     double normalized_l = 0;\n>     double normalized_r = 0;\n> \n>     if (track->bits_per_sample == 8) {\n>         normalized_l = (*data - 127) / (double)127;\n>         normalized_r = ((*(data + 1)) - 127) / (double)127;\n>     } else {\n>         normalized_l = (*((short *)data)) / (double)32767;\n>         normalized_r = (*((short *)(data + 2))) / (double)32767;\n652d357\n<   } else {\n654,662c359,388\n<   }\n<   i = 0;\n<   while ((unsigned int )i < track->sub_chunk2_size / (unsigned int )track->block_align) {\n<     j = 0;\n<     while (j < 12) {\n<       freq_bars[j].max_power = (double )0;\n<       freq_bars[j].total_power = (double )0;\n<       freq_bars[j].freq_count = 0;\n<       j ++;\n---\n> \n>     const int w = 83;\n>     int chan_w = w / 2;\n>     int y = (chan_w - 2) / 2;\n>     int x_l = (normalized_l * y) + y + .5;\n>     int x_r = (normalized_r * y) + y + chan_w + 1.5;\n>     char line[w];\n>     cgc_memset(line, ' ', w);\n>     line[w-1] = '\\0';\n>     line[chan_w] = '|';\n>     line[x_l] = '*';\n>     line[x_r] = '*';\n>     cgc_printf(\"%s\\n\", line);\n> }\n> \n> void cgc_wave_vis(uwfc_t *track) {\n>     unsigned char *data = (unsigned char*)track->data;\n>     cgc_size_t i = 0;\n> \n>     while (i < (track->sub_chunk2_size / track->block_align)) {\n>         if (i % track->sample_rate == 0)\n>             cgc_slow_vis();\n> \n>         if (track->num_channels == 2)\n>             cgc_plot_stereo_wave(track, data);\n>         else if(track->num_channels == 1)\n>             cgc_plot_mono_wave(track, data);\n> \n>         i++;\n>         data += track->block_align;\n664,667d389\n<     j = 0;\n<     while (1) {\n<       if ((unsigned int )j < track->sample_rate) {\n<         if ((unsigned int )i < track->sub_chunk2_size / (unsigned int )track->block_align) {\n669,679c391,392\n<         } else {\n<           break;\n<         }\n<       } else {\n<         break;\n<       }\n<       if ((int )track->bits_per_sample == 8) {\n<         normalized_l = (double )((int )*data - 127) / (double )127;\n<         if ((int )track->num_channels == 2) {\n<           normalized_r = (double )((int )*(data + 1) - 127) / (double )127;\n<         } else {\n---\n>     cgc_printf(\"++++END VISUALIZATION++++\\n\\n\");\n> }\n681,686c394,406\n<         }\n<       } else {\n<         normalized_l = (double )*((short *)data) / (double )32767;\n<         if ((int )track->num_channels == 2) {\n<           normalized_r = (double )*((short *)(data + 2)) / (double )32767;\n<         } else {\n---\n> typedef struct {\n>     double total_power;\n>     double max_power;\n>     int freq_count;\n> } eq_bucket_t;\n> \n> static void cgc_add_to_bucket(eq_bucket_t *buckets, complex_t *f, int f_i, int f_max) {\n> \n>     int b_i = (int)(cgc_sqrt(f_i / (double)f_max) * 12);\n>     double power;\n>     eq_bucket_t *bucket = &buckets[b_i];\n> \n>     power = cgc_pow(f->real, 2) + cgc_pow(f->imag, 2);\n687a408,439\n>     if (power > 4)\n>         bucket->total_power += power;\n>     if (bucket->max_power < power)\n>         bucket->max_power = power;\n> \n>     bucket->freq_count++;\n> }\n> \n> static void cgc_vis_buckets(eq_bucket_t *buckets, int vis_type) {\n>     int i;\n>     const int max_height = 90;\n>     char line[max_height + 1];\n> \n>     cgc_slow_vis();\n>     if (vis_type == 1) {\n>         int h;\n>         for (h = max_height; h >= 0; h--) {\n>             cgc_printf(\"   \");\n>             for (i = 0; i < 12; i++) {\n> \n> \n> \n>                 if (h == 0) {\n>                     cgc_printf(\"|-----|\");\n>                 } else if (h <= (int)(cgc_log(buckets[i].max_power))) {\n>                     cgc_printf(\"|=====|\");\n>                 } else {\n>                     if( h <= 30)\n>                         cgc_printf(\"|     |\");\n>                 }\n>             }\n>             cgc_printf(\"\\n\");\n689,698c441,457\n<       }\n<       *(dft_inputs_l + j) = normalized_l;\n<       if ((int )track->num_channels == 2) {\n<         *(dft_inputs_r + j) = normalized_r;\n<       } else {\n< \n<       }\n<       j ++;\n<       i ++;\n<       data += (int )track->block_align;\n---\n>     } else if(vis_type == 2) {\n>         double total_power = 0;\n>         int bar_width = 2;\n>         int bar_len = 0;\n>         for (i = 0; i < 12; i++)\n>             total_power += buckets[i].total_power;\n> \n> \n> \n> \n>         bar_len = (int)(cgc_log(total_power + 1) * 3);\n>         cgc_memset(line, 0, max_height + 1);\n>         cgc_memset(line, '=', bar_len );\n> \n>         line[bar_len] = ']';\n>         for(i = 0; i < bar_width; i++)\n>             cgc_printf(\"%s\\n\", line);\n700,703c459\n<     dft_output_l = cgc_dft(dft_inputs_l, (unsigned int )j, & len);\n<     if ((int )track->num_channels == 2) {\n<       dft_output_r = cgc_dft(dft_inputs_r, (unsigned int )j, & len);\n<     } else {\n---\n> }\n704a461,479\n> void cgc_eq_vis(uwfc_t *track, int vis_type, int filter_type) {\n>     int i, j, len;\n>     unsigned char *data = (unsigned char*) track->data;\n>     double *dft_inputs_l;\n>     double *dft_inputs_r;\n>     complex_t *dft_output_l= (0);\n>     complex_t *dft_output_r = (0);\n>     double normalized_l;\n>     double normalized_r;\n>     eq_bucket_t freq_bars[12];\n> \n>     dft_inputs_l = cgc_malloc(track->sample_rate * sizeof(double));\n>     if (dft_inputs_l == (0))\n>         return;\n> \n>     if (track->num_channels == 2) {\n>         dft_inputs_r = cgc_malloc(track->sample_rate * sizeof(double));\n>         if (dft_inputs_r == (0))\n>             return;\n706,723d480\n<     if (filter_type == 1) {\n<       k = (int )((track->sample_rate * 4U) / 20U);\n<       while (1) {\n<         if (k < j) {\n<           if ((unsigned int )k < (track->sample_rate * 16U) / 20U) {\n< \n<           } else {\n<             break;\n<           }\n<         } else {\n<           break;\n<         }\n<         (dft_output_l + k)->real = (double )0;\n<         (dft_output_l + k)->imag = (double )0;\n<         if ((int )track->num_channels == 2) {\n<           (dft_output_r + k)->real = (double )0;\n<           (dft_output_r + k)->imag = (double )0;\n<         } else {\n724a482,487\n>     i=0;\n>     while (i < (track->sub_chunk2_size / track->block_align)) {\n>         for (j = 0; j < 12; j++) {\n>             freq_bars[j].max_power = 0;\n>             freq_bars[j].total_power = 0;\n>             freq_bars[j].freq_count = 0;\n726,739c489,508\n<         k ++;\n<       }\n<     } else\n<     if (filter_type == 2) {\n<       k = 0;\n<       while (1) {\n<         if ((unsigned int )k < (track->sample_rate * 2U) / 20U) {\n<           if (k < j) {\n< \n<           } else {\n<             break;\n<           }\n<         } else {\n<           break;\n---\n> \n>         j=0;\n>         while(j < track->sample_rate && i < (track->sub_chunk2_size / track->block_align)) {\n>             if (track->bits_per_sample == 8) {\n>                 normalized_l = (*data - 127) / (double)127;\n>                 if (track->num_channels == 2)\n>                     normalized_r = ((*(data + 1)) - 127) / (double)127;\n>             } else {\n>                 normalized_l = (*((short *)data)) / (double)32767;\n>                 if (track->num_channels == 2)\n>                     normalized_r = (*((short *)(data + 2))) / (double)32767;\n>             }\n> \n>             dft_inputs_l[j] = normalized_l;\n>             if (track->num_channels == 2)\n>                 dft_inputs_r[j] = normalized_r;\n> \n>             j++;\n>             i++;\n>             data += track->block_align;\n741,746d509\n<         (dft_output_l + k)->real = (double )0;\n<         (dft_output_l + k)->imag = (double )0;\n<         if ((int )track->num_channels == 2) {\n<           (dft_output_r + k)->real = (double )0;\n<           (dft_output_r + k)->imag = (double )0;\n<         } else {\n747a511,525\n>         dft_output_l = cgc_dft(dft_inputs_l, j, &len);\n>         if (track->num_channels == 2)\n>             dft_output_r = cgc_dft(dft_inputs_r, j, &len);\n> \n>         int k;\n>         if (filter_type == 1) {\n> \n>             for (k = (track->sample_rate*4)/20; k < j && k < (track->sample_rate*16)/20; k++) {\n>                 dft_output_l[k].real = 0;\n>                 dft_output_l[k].imag = 0;\n>                 if (track->num_channels == 2) {\n>                     dft_output_r[k].real = 0;\n>                     dft_output_r[k].imag = 0;\n>                 }\n>             }\n749,759c527\n<         k ++;\n<       }\n<       k = (int )((track->sample_rate * 18U) / 20U);\n<       while (k < j) {\n<         break;\n<         (dft_output_l + k)->real = (double )0;\n<         (dft_output_l + k)->imag = (double )0;\n<         if ((int )track->num_channels == 2) {\n<           (dft_output_r + k)->real = (double )0;\n<           (dft_output_r + k)->imag = (double )0;\n<         } else {\n---\n>         else if (filter_type == 2) {\n760a529,550\n>             for (k = 0; k < (track->sample_rate * 2)/20 && k < j; k++) {\n>                 dft_output_l[k].real = 0;\n>                 dft_output_l[k].imag = 0;\n>                 if (track->num_channels == 2) {\n>                     dft_output_r[k].real = 0;\n>                     dft_output_r[k].imag = 0;\n>                 }\n>             }\n>             for (k = (track->sample_rate * 18)/20; k < j; k++) {\n>                 break;\n>                 dft_output_l[k].real = 0;\n>                 dft_output_l[k].imag = 0;\n>                 if (track->num_channels == 2) {\n>                     dft_output_r[k].real = 0;\n>                     dft_output_r[k].imag = 0;\n>                 }\n>             }\n>         }\n>         for (k = 0; k < j/2; k++) {\n>             cgc_add_to_bucket(&freq_bars[0], &dft_output_l[k], k, j/2);\n>             if (track->num_channels == 2)\n>                 cgc_add_to_bucket(&freq_bars[0], &dft_output_r[k], k, j/2);\n762,764d551\n<         k ++;\n<       }\n<     } else {\n766,772c553,554\n<     }\n<     k = 0;\n<     while (k < j / 2) {\n<       cgc_add_to_bucket(& freq_bars[0], dft_output_l + k, k, j / 2);\n<       if ((int )track->num_channels == 2) {\n<         cgc_add_to_bucket(& freq_bars[0], dft_output_r + k, k, j / 2);\n<       } else {\n---\n>         cgc_vis_buckets(&freq_bars[0], vis_type);\n>         cgc_free(dft_output_l);\n774,775c556,557\n<       }\n<       k ++;\n---\n>         if (track->num_channels == 2)\n>             cgc_free(dft_output_r);\n777,781d558\n<     cgc_vis_buckets(& freq_bars[0], vis_type);\n<     cgc_free((void *)dft_output_l);\n<     if ((int )track->num_channels == 2) {\n<       cgc_free((void *)dft_output_r);\n<     } else {\n783,787c560\n<     }\n<   }\n<   cgc_printf(\"++++END VISUALIZATION++++\\n\\n\");\n<   return;\n< }\n---\n>     cgc_printf(\"++++END VISUALIZATION++++\\n\\n\");\n"
    }
  ]
}