{
  "repair_begin": "2020-10-19 13:21:20.405844",
  "repair_end": "2020-10-19 13:22:15.621720",
  "patches": [
    {
      "target_file": "src/service.c",
      "fix": "no repair found",
      "edits": [
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / ) ; \n>  = NULL ; \n> goto / ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( - ) ; \n>  = NULL ; \n> goto break ; \n",
        "184,191c184,186\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( ; \n",
        "184,191c184,186\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( - ) ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n>  : \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \t / / ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read , newline ) ; \n>  ( \"Read ) ; \n>  : \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID && size < newline ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \t / / ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read ) ; \n>  : \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> goto / ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( - ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / = ( ; \n> goto / ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN , newline ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / , newline ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! p -> NumSamples ) { \n>  ( p ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! p -> NumSamples ) { \n>  ( p overflow , pcm value : : i ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / ) ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read , newline ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( size < 0 || p -> NumSamples == 0 ) { \n> return - EINVAL ; \n>  } \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / make ) { \n>  : \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / , newline ) ; \n>  ( \"Read ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> goto / ; \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( - ) ; \n>  = NULL ; \n> goto error ; \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> int / / ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read ) ; \n>  = \n>  ; \n>  : \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( size < 0 || p -> NumSamples == 0 ) { \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID && size < newline ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / make ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! p -> NumSamples && newline < newline ) { \n> return ( newline ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! newline ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm , : : % d ) ; \n> return break ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / ) ; \n>  = \n>  ; \n>  : \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> int / make ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / , newline ) ; \n>  ( \"Read , newline ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ; \n>  : \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / <= 0 ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / newline ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n> return ret ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! newline ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm , : : % d ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,186\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / ) ; \n>  : \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / overflow , newline value : : ( ) ; \n> return ( - ) ; \n>  = NULL ; \n> break ; \n>  : \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n>  ( / , newline ) ; \n>  ( \"Read ) ; \n>  ( \"Read ) ; \n>  = NULL ; \n> break ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / make ) { \n>  : \n>  = ( char * ) 0 ; \n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( STDIN ) ; \n> if ( ! p -> NumSamples ) { \n>  ( p ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / = ( ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n> \n"
      ]
    }
  ],
  "comps": 1,
  "failed_comps": 50,
  "passed_tests": 0,
  "failed_tests": 0,
  "duration": 55.215876,
  "error": "Return code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\n"
}