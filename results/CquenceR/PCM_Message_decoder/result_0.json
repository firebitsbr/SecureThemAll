{
  "repair_begin": "2020-10-23 18:33:02.326665",
  "repair_end": "2020-10-23 18:33:41.191653",
  "patches": [
    {
      "target_file": "src/service.c",
      "fix": "no repair found",
      "edits": [
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return 0 ; \n>  } \n> \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / & size ) { \n>  ( p ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n> return ret ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> static / / ( size ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples == 0 ) { \n>  ( fd ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n>  ( & size , newline ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> static int / ( size ) ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> / / ( size ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n> return ret ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n>  ( INVALID_PCM_FMT ) ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples > 16 ) { \n>  ( fd ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / & size ) { \n>  ( p ) ; \n>  = NULL ; \n> break ; \n>  } \n> return ret ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \t / / ( size ) ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> spnego_gss_ctx_id_t / / ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples > 16 ) { \n>  ( fd ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n>  ( & size , 0 ) ; \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n> return ret ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples == 0 ) { \n>  ( fd ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples > 16 ) { \n>  ( fd overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> uint64_t / / ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples == 0 ) { \n>  ( fd ) ; \n> return - EINVAL ; \n>  } \n>  ( / ) ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples == 0 ) { \n>  ( fd overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n>  / ( size ) ; \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples > 16 ) { \n>  ( fd overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184,185\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n> already_AddRefed < / / || / make ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! size != lp ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184,189\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n>  = NULL ; \n> break ; \n>  } \n> \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / make ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( size < 0 || p -> NumSamples == 0 ) { \n>  ( fd overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM overflow , pcm value : : ( ) ; \n> return break ; \n>  } \n> \n",
        "184,191c184,187\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / & size ) { \n>  ( p ) ; \n> return - EINVAL ; \n>  } \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! / & size ) { \n>  ( p ) ; \n>  = NULL ; \n> break ; \n>  } \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> \t / / ) ; \n",
        "184,191c184\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> unsigned / / ( size ) ; \n",
        "184,191c184,188\n<   \n<   // make sure the SampleSize value is valid\n<   // BUG. Check is done with integer division instead of\n<   // floating point which leads to an incorrectly\n<   // checked DataSize\n<   if (p->DataSize*8/p->NumSamples != 16) {\n<     cgc_puts(\"Invalid PCM length\\n\");\n<     cgc__terminate(INVALID_PCM_LEN);\n---\n> if ( ! p -> ID ) { \n>  ( UNABLE_TO_PARSE_PCM ) ; \n> return - EINVAL ; \n>  } \n> \n"
      ]
    }
  ],
  "comps": 1,
  "failed_comps": 50,
  "passed_tests": 0,
  "failed_tests": 0,
  "duration": 38.864988,
  "error": "Return code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\n"
}