{
  "repair_begin": "2020-10-19 13:21:32.610552",
  "repair_end": "2020-10-19 13:22:42.245394",
  "patches": [
    {
      "target_file": "src/fs.c",
      "fix": "no repair found",
      "edits": [
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ? d : MAX ; \n> return ( ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t ( & index ) ; \n1082a1081\n> for ( i = 0 ; i < size || b_index > nmemb ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > i ; \n653c654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / / ( - index ) ; \n1082a1084\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return break ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES > i ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i < size && index -> size ; i ( ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return break ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) == dir ) { \n>  ( dir overflow , allow \n>  : : d ) ; \n> return - - ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ( last_inode ) ) \n> \t \t \t return - EINVAL ; \n> \n1082a1087\n> for ( i = 0 ; i < size ? size : i ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : % d ( 0 ) ; \n> return break ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = 0 ; i < size ? size : i - index ) { \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / out ; \n1082a1080\n> for ( i = 0 ; i >= size ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ; \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( last_inode ( index ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && index -> size ; i ( ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return break ; \n> \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES ) { \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( last_inode ( index ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088\n> for ( i = 0 ; i < size || index -> size > nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir <= ( ) { \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / \n1082a1080\n> for ( i = 0 ; i < size ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && last_inode <= MAX_DIR_INODES ) { \n653c654,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / = free ; \n1082a1085\n> for ( i = 0 ; i < size && i * nmemb ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) == dir ) { \n>  ( dir overflow , allow \n>  : : d ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && last_inode <= ( ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1087\n> for ( i = INODE_DATA_BLOCKS ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : % d ( 0 ) ; \n> \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && MAX_CMD <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) \n> \t \t \t return - EINVAL ; \n> \n1082a1086\n> for ( i = 0 ; i < size || b_index > nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / / ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) ; \n>  / allow ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ) ; \n1082a1081\n> for ( i = 0 ; i < size || stream == nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > i ) { \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t return - EINVAL ; \n1082a1080\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = indirect_inode ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; i + MAX_DIR_INODES ; \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size * nmemb ; i ++ ) ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ; i ) ; \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t goto dir ; \n> \t \t } \n1082a1088\n> for ( i = 0 ; i < size ? size : i - 2 ) { \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ; \n>  the \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && yes, <= MAX_DIR_INODES ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n1082a1081\n> for ( i = 0 ; i < size * * nmemb ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ; \n> if ( ! allow ) { \n>  ( allow overflow , 0 \n>  : : d ) ; \n> return break ; \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ; \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( last_inode ( inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1088\n> for ( i = 0 ; i < size || b_index > nmemb ; i ++ ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) == dir ) { \n>  ( dir overflow , allow \n>  : : % d ( 0 ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES < dir ) { \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088,1089\n> for ( i = 0 ; i < size ; \n> int ( i ) ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1081\n> for ( i = curr_pos_inode ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < actual_size ; \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( last_inode ( inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088\n> for ( i = 0 ; i < size || stream -> size > nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ) { \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / \n1082a1082\n> for ( i = 0 ; i < size ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; i + MAX_DIR_INODES ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t } \n> \n1082a1086\n> for ( i = 0 ; i >= size && index -> size > index ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ; \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ) { \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / / ; \n> \n1082a1082\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && stream > nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow && allow < d ) { \n>  ( \"invalid overflow , 0 ( : : d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && MAX_CMD <= ( ) { \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087,1088\n> for ( i = 0 ; i < size ; \n> int size = ( ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : % d ( 0 ) ; \n> if ( ! cgc_strcmp ) { \n> return ( ; \n>  } \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> \t for ( i = 0 ; \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! in -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087\n> for ( i = 0 ; i < size && i < nmemb * nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; \n1082a1080\n> for ( i = 0 ; i < size ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1088\n> for ( i = 0 ; i < size ? size : i ; i ( = NULL ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n> return NULL ; \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && in -> MAX_DIR_INODES > i ; \n653c656,659\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1089,1090\n> for ( i = 0 ; i < size ? size : i - 2 ) { \n> \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval = / the directory ; \n>  : \n> \t \t \n>  ( allow , allow ) ; \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / ( ( , free ) ; \n1082a1084\n> for ( i = 0 ; i < size && stream > nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n>  / allow ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i + MAX_DIR_INODES ; \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES > index ; \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! in -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size && stream > nmemb ; i ++ * nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> ! \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i + MAX_DIR_INODES ; \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; \n> \n1082a1081\n> for ( i = 0 ; i < size * ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return break ; \n> \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size && index -> size > nmemb ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir <= ( ) { \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086,1087\n> for ( i = 0 ; i < size ? size : i ; \n> \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) == dir ) { \n>  ( dir overflow , allow \n>  : : % d ( 0 ) ; \n> \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size && index -> size ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : MAX ) ; \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES < 5 ) { \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i >= size && b_index < in * nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ; \n>  the \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / ( ( ) ; \n1082a1081\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : % d ( 0 ) ; \n> if ( ! cgc_strcmp ) { \n> return ( ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES < 5 ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size * nmemb ; i ++ * nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval = / the directory ; \n> if ( ! allow ) { \n>  ( allow overflow , 0 \n>  : : d ) ; \n> return break ; \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < 5 ) { \n653c656,659\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1089\n> for ( i = 0 ; i < size && i * nmemb ; i ++ ) { \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> retval : : / < allow > directory ? d : MAX ; \n> return ( ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , 0 the : : % d ( 0 ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && update <= MAX_DIR_INODES ) { \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087\n> for ( i = in2 ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \t / cgc_strcmp ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t return - EINVAL ; \n> \n1082a1081\n> for ( i = b_index ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n> \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( ! allow ) { \n>  ( allow overflow , 0 ( : : d ) ; \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES > i ) { \n653c654,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  / \n1082a1085\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n"
      ]
    }
  ],
  "comps": 1,
  "failed_comps": 50,
  "passed_tests": 0,
  "failed_tests": 0,
  "duration": 69.634842,
  "error": "Return code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\n"
}