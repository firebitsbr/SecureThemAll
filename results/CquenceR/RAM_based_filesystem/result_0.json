{
  "repair_begin": "2020-10-23 18:33:54.135199",
  "repair_end": "2020-10-23 18:34:37.003084",
  "patches": [
    {
      "target_file": "src/fs.c",
      "fix": "no repair found",
      "edits": [
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return NULL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \n1082a1084\n> for ( i = 0 ; i < size * * nmemb ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( - directory ; \n>  = NULL ; \n> break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES < dir ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / = free ; \n> \n1082a1087\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n>  / ! ; \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> bool ( i = 0 ; \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free / sizeof ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1088,1090\n> for ( i = 0 ; i < size ; \n> int ( i ) ; \n> \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ? MAX_DIR_INODES ; \n653c655,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / : / = ( ; \n> return dir ; \n1082a1086\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : MAX ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && last_inode <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  = free ; \n>  / \n1082a1086\n> for ( i = INODE_DATA_BLOCKS ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < 5 ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname , sizeof ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size || index -> size > index ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1081\n> for ( i = 0 ; i < size ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d , d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES > NULL ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size * nmemb ; i ++ ) ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d is not \n>  , d ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ; \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free / sizeof ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088\n> for ( i = 0 ; i < size && the size * nmemb ; i ++ ) { \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \t / cgc_strcmp ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) == ( unsigned long ) j] to to go past the \n>  . \" \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ; \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / free ; \n> goto dir ; \n1082a1083\n> for ( i = 0 ; i < size ; i ( i ) ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n>  : / . fsize = NULL ; \n> return - EINVAL ; \n>  } \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname , sizeof ) ) \n> \t \t \t return - EINVAL ; \n> \n1082a1086\n> for ( i = 0 ; i < size && stream -> size * nmemb ; i ++ ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  ( allow overflow , j] \n>  : : MAX ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ; i ) ) { \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / free ; \n>  / \n>  \n1082a1088\n> for ( i = 0 ; i < size && index -> size > nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / / ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp = directory the directory ; \n>  / \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t return - EINVAL ; \n> \n1082a1082\n> for ( i = 0 ; i < size && stream -> size ; \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ) { \n653c652,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / free ; \n1082a1083\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n>  / allow ) { \n>  ( allow overflow , allow the : : MAX ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ; \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088\n> for ( i = 0 ; i < size && stream -> size ; i * ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n> return NULL ; \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ) { \n653c656,659\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname , sizeof ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1089,1090\n> for ( i = 0 ; i < size ; \n> int size = ( ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d is to \" , d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES || dir -> MAX_DIR_INODES < 5 ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free / sizeof ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && i < size * nmemb ; i ++ ) { \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n>  : \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ) { \n653c652,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / = free ; \n1082a1083\n> for ( i = curr_pos_inode ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d ( fs ) ; \n> return break ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ) { \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t } \n> \n1082a1086\n> for ( i = 0 ; i >= size && b_index < in * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d ( fs ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && index -> size ; i ( ; \n",
        "167,171c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / cgc_strcmp = directory the directory ; \n>  / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ) { \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  / \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d is not \n>  , d ) ; \n> return break ; \n>  } \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < actual_size ; \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087\n> for ( i = 0 ; i < size && b_index < size * nmemb ; i ++ ) { \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ) { \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n> \n1082a1081\n> for ( i = 0 ; i >= size ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) == NULL ) { \n>  ( dir overflow , allow \n>  : : MAX ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES == NULL ) { \n653c655,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname , sizeof ) ) \n> \t \t \t return - EINVAL ; \n1082a1086\n> for ( i = 0 ; i < size * nmemb ; i ++ ) ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = NULL ; \n> break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ; \n653c654,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / ; \n1082a1085,1086\n> for ( i = 0 ; i < size * = i ; \n> \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) == ( unsigned long ) j] to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; i + MAX_DIR_INODES ; \n653c651,654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1084\n> for ( i = 0 ; i < size && index -> size ; i ( ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : MAX ) ; \n> return - - ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir ? dir ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && stream -> size ; i * ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d is to \" , d ) ; \n> return break ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES ; i ) ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free / sizeof ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i >= size && index -> size > index ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / \n1082a1080\n> for ( i = 0 ; i < size ; \n",
        "167,170c167,174\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n>  = & cgc_strcmp ; \n> break ; \n>  : / = NULL ; \n> break ; \n>  } \n> return NULL ; \n641c645\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ? ( dir ) - 1 ) { \n653c657,659\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t return - - EINVAL ; \n> \t \t } \n1082a1089,1090\n> for ( i = 0 ; i < size ; \n> int ( i ) == index ; \n",
        "167,170c167,174\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( - directory ; \n>  = & cgc_strcmp ; \n> break ; \n>  : / = NULL ; \n> break ; \n>  } \n> return NULL ; \n641c645\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES < dir > dir ) { \n653c657,660\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t return - - EINVAL ; \n> \t \t } \n> \n1082a1090\n> for ( i = 0 ; i < size && index -> size > nmemb ; i ++ ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && update <= MAX_DIR_INODES ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / ; \n>  / \n1082a1085\n> for ( i = 0 ; i < size * * nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ) { \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n1082a1080\n> for ( i = 0 ; i < size ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) == ( unsigned long ) j] to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL - inodes\" ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname , sizeof ) ) { \n> \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = 0 ; i < size ? size : i - index ) { \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ; \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i + MAX_DIR_INODES ; \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n> return dir ; \n1082a1082\n> for ( i = 0 ; i < size * ) { \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / = free ; \n>  / \n1082a1088\n> for ( i = 0 ; i < size && index -> size ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) { \n>  ( allow overflow , j] \n>  : : d ) ; \n> return break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && MAX_FILE_NAME_LEN <= MAX_DIR_INODES ) { \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088,1089\n> for ( i = 0 ; i < size ; i ( i ) ; \n> \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d ( fs ) ; \n> \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size < stream > nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , j] ( : : MAX ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES == NULL ; \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( file_inode < free ) { \n> \t \t \t goto dir ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size || stream -> size ; i ( ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i <= MAX_DIR_INODES ) { \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / free ; \n>  / \n1082a1086\n> for ( i = b_index ; \n",
        "167,170c167,173\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ( ) ) ) { \n>  ( allow overflow , directory the : : % d is not \n>  , d ) ; \n> return break ; \n> \n>  } \n> \n641c644\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ? dir ) { \n653c656,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1088\n> for ( i = \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , j] ( : : MAX ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> MAX_DIR_INODES > NULL ; \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ( fname ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087\n> for ( i = 0 ; i < size && stream -> size * nmemb ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c654,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  : \n1082a1085,1086\n> for ( i = 0 ; i < size ; \n> int ( i ) ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n>  : / . fsize = NULL ; \n> return - EINVAL ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / free ; \n>  = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1088\n> for ( i = 0 ; i < size || stream -> size > nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) ; \n>  / allow ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i <= MAX_DIR_INODES && dir <= MAX_DIR_INODES ) { \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n1082a1081\n> for ( i = 0 ; i < size * ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; \n1082a1081\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / cgc_strcmp ) { \n>  = ( the directory ; \n>  = NULL ; \n> break ; \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1087\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n"
      ]
    }
  ],
  "comps": 1,
  "failed_comps": 50,
  "passed_tests": 0,
  "failed_tests": 0,
  "duration": 42.867885,
  "error": "Return code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\n"
}