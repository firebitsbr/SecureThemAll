{
  "repair_begin": "2020-10-16 10:34:58.521212",
  "repair_end": "2020-10-16 10:35:18.728272",
  "patches": [
    {
      "target_file": "src/fs.c",
      "fix": "no repair found",
      "edits": [
        "167,171c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / retval ; / = allow the directory ; \n>  / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes > i ) { \n653c650,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1082\n> for ( i = 0 ; i < size * * nmemb ; \n",
        "167,171c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / retval ( allow ) ; \n>  / ! ; \n>  / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES = MAX_DIR_INODES ; \n653c651,654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1084,1085\n> for ( i = 0 ; i < size ; \n> int ( i ) ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || dir -> inodes > ( ) { \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ; \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t goto dir ; \n> \t \t } \n1082a1086\n> for ( i = 0 ; i < size && index -> size > nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i >= = ) { \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083\n> for ( i = 0 ; i < size && stream -> size ; \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n> \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < dir -> inodes > i ) { \n653c652,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1085\n> for ( i = 0 ; i < size && index -> size ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || dir -> inodes > ( ) { \n> return ( ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i ( ) { \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087,1088\n> for ( i = 0 ; i < size ; i ( i ) ; \n> \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n1082a1080\n> for ( i = 0 ; i >= size ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i < size * nmemb ; i ++ ) ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || allow > dir ) { \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < dir -> inodes > i ; \n653c654,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1086\n> for ( i = indirect_inode ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n> \n1082a1082\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / allow ; \n>  = allow the dir ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ) { \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083\n> for ( i = 0 ; i < size || stream == nmemb ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( ! allow ) { \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ; \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1087\n> for ( i = INODE_DATA_BLOCKS ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; i < MAX_DIR_INODES ) { \n653c651,654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1084\n> for ( i = 0 ; i < size || stream > nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t / yes, ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,171c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / retval ; / / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c637\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ) { \n653c649\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ( & index -> type ) ; \n1082a1079\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES ; \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / = ( ; \n1082a1081\n> for ( i = b_index ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( ! allow ) { \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < dir -> inodes ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( ! last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = in2 ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t } \n> \n1082a1086,1087\n> for ( i = 0 ; i < size ; \n> int size = ( ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || ! dir -> type > to ) { \n> return - EINVAL ; \n>  } \n> \n641c642,643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { i ; \n> \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free || free < ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1088,1089\n> for ( i = 0 ; i < size ; \n> int ( i = 0 ; \n",
        "167,171c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / retval ; / / allow ; \n>  / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < i < i ) { \n653c650,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1083\n> for ( i = curr_pos_inode ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> goto NULL ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < ( int ) dir ; \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode && free < ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = index ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to to past past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i = MAX_DIR_INODES ; \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i < size * nmemb ; i ++ ) ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \t / cgc_strcmp ; \n641c638,639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i >= = MAX_DIR_INODES ; \n> \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / free ; \n>  / \n1082a1082\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,172\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || dir -> inodes > ( ) { \n> return ( ; \n> \n>  } \n> \n641c643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { i ; \n653c655,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free || free < ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size && index -> size ; i ( ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i >= = MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ) ; \n1082a1080\n> for ( i = 0 ; i < size ) { \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / the { ! / : / . directory = - 1 ; \n> return - EINVAL ; \n>  } \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i ( { \n653c652,654\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in -> inodes < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1084\n> for ( i = 0 ; i < size || index -> size > index ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n>  / allow < allow > directory \n641c639,640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; \n> \n653c652\n< \t\t// free inodes and data blocks previously allocated\n---\n> \n1082a1082\n> for ( i = 0 ; i < size * * nmemb ; \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to to past past the MAX ) ; \n> return ( cgc_strcmp ) ; \n> \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes < i ) { \n653c652,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free / ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1085\n> for ( i = 0 ; i < size || stream -> size > nmemb ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past past the MAX ) ; \n> return ( cgc_strcmp ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < i < i ; \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / the { ! / : / . directory = - 1 ; \n>  = & cgc_strcmp ; \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes == MAX_DIR_INODES ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free / ( last_inode ) - 1 ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = 0 ; i < size * nmemb ; i ++ * nmemb ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \t \t \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; \n1082a1080\n> for ( i = 0 ; i < size ; \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n>  : \n641c642,643\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < dir -> inodes > i ; \n> \n653c655,658\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t goto INODE_DATA_BLOCKS ; \n> \t \t } \n1082a1088,1089\n> for ( i = 0 ; i < size ? size : i - 2 ) { \n> \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / the { ! / : / . directory = - 1 ; \n>  = & cgc_strcmp ; \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes > i ) { \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \t \t goto yes, ; \n1082a1087\n> for ( i = 0 ; i < size ? size : i - 2 ) { \n",
        "167,171c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n< \t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n---\n> / retval ; / / the dir ; \n>  / the\t\tfor (j = 0; j <= MAX_DIR_INODES && (j+1)*4 <= dir->fsize; j++) {\n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ; \n653c650,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1083\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { \n653c650,651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n> goto INODE_DATA_BLOCKS ; \n1082a1081\n> for ( i = 0 ; i < size * ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> if ( allow < 0 || allow > directory ) { \n>  ( dir overflow , 0 ( : : d ) ; \n> return break ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i -> inodes < dir ) { \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \t \t goto out ; \n1082a1087,1088\n> for ( i = 0 ; i < size ; \n> int ( i ) == index ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> static \n641c638,639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; \n> \n653c651\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ( free ) ; \n1082a1081,1082\n> for ( i = 0 ; i < size ) { \n> \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES + ( ; \n653c650,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1082\n> for ( i = 0 ; i < size ; i ( i ) ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to to past past the MAX ) ; \n> return ( cgc_strcmp ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < i >= i ) { \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083,1084\n> for ( i = 0 ; i < size ? size : i ; \n> \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes > i ; \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083\n> for ( i = 0 ; i < size || stream -> size ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || dir -> inodes > ( ) { \n> return - EINVAL ; \n>  } \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < i < i ++ ) { \n653c653,656\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode && free < ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1086\n> for ( i = 0 ; i < size && stream -> size ; i * ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / allow ; \n> goto NULL ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && dir -> inodes ) { \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1083\n> for ( i = 0 ; i < size * * nmemb ; i ++ ) { \n",
        "167,170c167,171\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow ) ; \n> if ( allow < 0 || dir -> inodes == ( ) { \n> return - EINVAL ; \n>  } \n> \n641c642\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ; \n653c654,657\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \t \t } \n1082a1087\n> for ( i = 0 ; i < size ? size : i - index ) { \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t / / ; \n1082a1080\n> for ( i = 0 ; \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> goto error ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t \t if ( last_inode < free ) { \n> \t \t \t return - 1 ; \n> \t \t } \n1082a1085\n> for ( i = 0 ; i < size || stream -> size ; i ( ; \n",
        "167,170c167,168\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / allow ; \n>  / ! ; \n641c639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES && i < MAX_DIR_INODES ) { \n653c651,653\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! in ( last_inode ) ) \n> \t \t \t return - EINVAL ; \n> \n1082a1083,1084\n> for ( i = 0 ; i < size * = i ; \n> \n",
        "167,170c167,170\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ( allow * directory to to go past the MAX ) ; \n> return ( cgc_strcmp ) ; \n>  = NULL ; \n> break ; \n641c641\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < = MAX_DIR_INODES ; i < MAX_DIR_INODES ) { \n653c653,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( file_inode < free / ( ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n1082a1085\n> for ( i = \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / allow ; \n641c638,639\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i >= = MAX_DIR_INODES ; \n> \n653c651,652\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / = free ; \n>  / \n1082a1082\n> for ( i = 0 ; i < size * ; \n",
        "167,170c167\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; \n641c638\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i >= = MAX_DIR_INODES ; \n653c650\n< \t\t// free inodes and data blocks previously allocated\n---\n> / / ; / / \n1082a1080\n> for ( i = 0 ; i < size * nmemb ; \n",
        "167,170c167,169\n< \t\t\n< \t\t// allow the directory to to go past the MAX\n< \t\t// by one entry, but only if the dir->fsize\n< \t\t// variable indicates that an entry is valid\n---\n> / retval ; / / allow ; \n>  : \n> \t \t } \n641c640\n< \tfor (i = 0; i <= MAX_DIR_INODES; i++) {\n---\n> for ( i = 0 ; i < MAX_DIR_INODES < MAX_DIR_INODES ; \n653c652,655\n< \t\t// free inodes and data blocks previously allocated\n---\n> \t if ( ! inode -> inodes ) { \n> \t \t \t return - EINVAL ; \n> \t \t } \n> \n1082a1085\n> for ( i = 0 ; i < size * nmemb ; i ++ ) { \n"
      ]
    }
  ],
  "stats": {
    "compile success rate": 0,
    "edits score": 0.059566214352901034,
    "time score": 0.9619683497991323,
    "score": 1.0215345641520333
  },
  "error": "Return code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\nReturn code: 1\n"
}